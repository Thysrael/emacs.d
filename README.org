#+TITLE: EMO

* 选择
在我结束了大三和保研的事情后，我希望我可以干一些自己想干的事情。配置一款“我自己”的编辑器再次被我提上日程。

vscode 和 sublime text 被我早早划去了，没有任何原因，只是不够帅气。但是对于 vim 和 emacs 的选择，却让我纠结了很久，以至于需要写一个段落来坚定自己的心思。

vim 实在是太诱人了：我曾经配置过它；neovide 漂亮的光标移动特效（果冻光标），而且它最近还支持中文了；十分帅气潇洒的多模式编辑；在比较极端的条件下可以应用；因为专注于编辑功能，所以配置的背景知识不需要太多，而且中文教程很多。但是我依然没有选择 vim，这是因为我突然想到，当我就算配置完了 vim，那么我不过收获了一个编辑速度更快的编辑器，就算比 vscode 快，那又如何？我想要一个“我自己”的本质是什么？我虽然不知道“我自己”是什么，但是我知道，现在的我一定不是“我自己”。

emacs 则相反：因为它不只是一个编辑器，更像是一种生活方式（起码是工作方式），所以要花很多时间去了解各个方面；它的 GUI 和中文支持并不太好，我还记得我花了很长时间去配置字体等宽和输入法；键绑定永远的痛，默认快捷键和熟悉的 CUA 模式完全不一样，而且相比于 vim 还很对手指不友好、没有逻辑、还很难按；甚至启动时间也很慢，我看网上说甚至连大文本文件的处理也不如 vim 性能好。

但是我还是想使用 emacs，我觉得 emacs 对我而言，是一种更多的可能性。

* Emacs 的小而精哲学
** 小而精
随着配置的深入，我再次深深意识到了 emacs 和 vim 的不同。vim 是一个专注于文本编辑的编辑器，它确实很符合 Unix “只干一件事情并将它干好”的特质，对于“编辑”这一件事情，vim 已经做到很好了。

不过话说回来，难道我的工作只是“编辑文本”吗？显然不是的，为了完成一个项目，需要找灵感，查资料，做设计，团队沟通，代码实现，部署调试，写文档，做展示，发布产品，这期间又伴随着质量检测，版本控制，日程规划等多个事宜。不得不说，vim 或者 vscode 确实可以做一个或者多个工作，比如和代码实现联系密切的文档撰写，版本控制，部署调试都可以在这些现代化的编辑器中完成。不过有一说一，vim 在除了文本编辑外的工作只能说是中规中矩，比较好的优点是 vim 的多模态使得很多功能按键的绑定十分有逻辑。更有很多工作场景是 vim 无所发力的（比如说浏览器，PDF 阅读器，多媒体，团队沟通），这也正是 tmux 或者 i3wm 这样窗口或者桌面管理器存在的意义。我们需要一个管理多个开发工具的工具（比如 tmux 和 i3wm）来协作很多和 vim 一样“小而精”的工具。

那么为什么 vim 要设计成这样，难道不能设计成和 office 软件一样的“大而全”吗？只需要打开一个 word，就可以完成文档撰写，排版，团队批注，多媒体插入等多个功能，这是多么方便的用户体验呀。我觉得是这样的，“小而精”并没有很好概括 Unix 工具的本质特征，它们的本质是 *“只干一件事情，并将它干好，并且极其容易与其他工具进行配合”* 。在我说的这个前提下，我们假设一个团队的开发力（我瞎编的一个名词，表示一个团队开发软件的功能数）是 100，如果只开发 1 个“大而全”的软件，那么只能开发出具有 100 个功能的软件，而如果平等地开发 5 个“小而精”的软件，并且这些软件极易协作，那么组合起来的功能数则是 $(100 / 5)^5 = 3200000$ 个。这会大大丰富用户的功能并且提高定制性和趣味性（突然发现两个看似并不相关的工具居然可以有如此美妙的化学反应）。

** 工作环境范式
Unix 思想有一个重要的前提是“工具之间极其容易配合”。当然不得不说 Unix 工具是在这个方面做了一些贡献的，基本上所有的工具的输入都可以是 stdin，所有的输出都可以是 stdout，输入和输出内容都是字符串，有管道可以将他们的输入输出联系起来，并且还有许多数据整理工具可以过滤和格式化输入输出。在这个角度上看，Unix 规划的一种工作环境的范式是：“shell + Unix tool”，这种范式，shell （当然还有 tmux 这种终端复用器）负责将多个工具衔接在一起，其他工具负责具体的工作。不过这种范式是没有缺点的吗？当然不是了，shell script 是一个极其糟糕的语言，而且 shell 本质是一个 cli 工具，那么其多媒体表达功能必然会受到限制。

所以在我们普通人的生活中，我们常用“桌面环境 + GUI 工具”的范式，我们用桌面环境来协调多个工具，然后让浏览器，写作软件，编辑器，视频播放器等多个软件满足我们不同的需要。不过用桌面环境的协调真的是一种很好的协调吗？起码就我个人的体验来说，并不是。多个工具的配合一般只有两种方式：

- 使用复制粘贴：将浏览器文档里的 demo 代码 copy 到编辑器中试试能不能跑；将编辑器中出问题的代码复制到 chatgpt 上问问为啥？
- 使用人脑：脑子理解了浏览器文档里的内容，想了想再用编辑器写出来；耳朵听了音乐，看着屏幕傻乐，然后敲代码。

当我们再次回顾我们的目标： *“只干一件事情，并将它干好，并且极其容易与其他工具进行配合”* 。我们会发现我们上面讨论的范式并不让人满意，他们总有或多或少的缺陷，这些缺陷直接导致了我们“工作环境”的不舒适或者 *无趣性* ！

** The Ghost in Emacs
而当我们去看 emacs 的时候，会发现它居然不可思议地符合了“小而精”的哲学。它看上去是一个庞然大物（spacemacs 我甚至需要下载安装十五六分钟），但是他和 word 不同，它的功能都是独立且自由的，每个功能都是小而精的。他之所以看着“臃肿”，正是因为它本质上并不是一个需要“小而精”的编辑器，而是一个组织这些“小而精”工具的“工作环境”，在这点上，emacs 没有对手：

- 它采用了字符串来处理协作问题，这种最为朴素的方式使得各个插件的协作要求极低
- 它使用 elisp 来处理复杂协作问题，这种很学术、规整的语言可以天然抑制与调和编写脚本时的混乱与自由
- 它还具有良好的文档（这可能与他们的基础函数基本都支持文档字符串有关，并且设计者有意构建了一个更加秩序化的架构），使得人们很容易探索出多种工具的组合效果来
- 它还具有友善的社区。我并不知道这是如何发展起来的，我猜测可能是这个社区的人着眼于“工作环境”而非“工具”，所以视角更为宏大；同时对于工具而言，其核心目标是效率，所以很容易到达尽头，而对于环境而言，其核心目标是舒适和趣味，所以引起的讨论会更多。
- 它还支持 GUI，这点虽然并不是 emacs 原生的，但是不得不说这在某些方面是优于 CLI 工作环境的。 

有人将 emacs 比作“操作系统”，我想他们大概是也想表达和我一样的意思。不过操作系统并不只限于满足用户的工作环境需要，它的一部分功能是内核，另一个部分是函数库，这些都是与“工作环境”无关的（起码是侧重点不同的）。我更愿意将 emacs 视作“工作环境和环境里的工具”，和它对标的应该是“Shell + Cli Tool”、“KDE + Chrome + Vscode + Typora + ...”。

* 配置架构
正是遵循上文提出的思想，我将我的配置按照工作的场景来划分为不同模块。正因为不同模块对应不同场景，也就是不同需求，所以这样组织的配置，既有逻辑性，又有独特性：

** 通用设置（general）
这种设置是通用的，不区分工作环境的，可以看做是对于 emacs 本身的增强，这种增强又可以分为两个部分，即功能的增强和组件的增强:

- [[./core/init-package.el][package]]：包管理器配置，包括代理，源，包管理器的选择，配置目录整理等。
- [[./core/init-basic.el][basic]]：最为基础的配置，其核心目的是将 emacs 改造成一个舒适的记事本（裸 emacs 确实做不到这点）。
- [[./core/init-enhance.el][enhance]]：emacs 本身功能的增强配置（不会引入新的功能）。包括 minibuffer、检索、光标移动、窗口管理等。
- [[./core/init-modeline.el][modeline]]：modeline 配置，因为直接照抄 roife，所以从 ui 中移出。
- [[./core/init-ui.el][ui]]：包括字体、主题、光标、fringe 等组件配置。
- [[./core/init-shell.el][shell]]：终端配置。
- [[./core/init-util.el][util]]：工具类，用于存储方便配置或者自己写的工具函数
- [[./core/init-tmp.el][tmp]]：临时配置，用于存放尚未归类的配置或者实验性配置。

** 编辑配置（edit）
这部分集中于 emacs 编辑源码的能力，可以说是 vim 之前负责的部分：

- [[./core/init-edit.el][edit]]：通用编辑配置，包括补全、高亮、结构化编辑、撤销、搜索替换等。
- [[./core/init-prog.el][prog]]：源码分析与交叉引用，包括基于搜索匹配，tags，lsp 多种分析模式。
- [[./core/init-lang.el][lang]]：不同源码文件，启用不同的配置。
- [[./core/init-remote.el][remote]]：远端编辑配置。

** 项目管理配置（project）
会以项目的方式被组织和管理，同时在时间维度上需要引入版本控制和日程管理：

- [[./core/init-project.el][project]]：基础的项目管理配置，包括项目内检索，项目侧边栏等。
- [[./core/init-dired][dired]]：文件管理器配置。
- [[./core/init-vsc.el][vsc]]：版本控制配置，包括 chunk 和版本控制接口。
- [[./core/init-agenda.el][agenda]]：日程管理配置。
- [[./core/init-debug.el][debug]]：项目的编译、运行、调试和部署等方面。

** 写作配置（writing）
包括中文适配，文档撰写，博客撰写，论文撰写等（或许还考虑知识管理）：

- [[./core/init-org.el][org]]：org-mode 配置。
- [[./core/init-markdown.el][markdown]]：markdown 配置。
- [[./core/init-tex.el][tex]]：latex 配置。
- [[./core/init-input.el][input]]：中文输入配置，包括输入法配置和中英文协调配置。
- [[./core/init-blog.el][blog]]：博客撰写配置。
- [[./core/init-export.el][export]]：导出成多媒体内容，包括幻灯片，pdf，脑图等形式。

** 阅读配置（reading）
侧重于对于多媒体内容的浏览：

- [[./core/init-broswer.el][broswer]]：浏览器相关配置。
- [[./core/init-community.el][community]]：社交相关的配置，包括 RSS，email 等。
- [[./core/init-music.el][music]]：希望我不会 nerd 到有一天想在 emacs 上听音乐。

这种配置思路的缺点是忽略了不同功能模块之间的相互配合，那么趣味性会减少很多，所以应当通过学习多多在文档中记录这些知识。
